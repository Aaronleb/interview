# JVM
## 1、GC是什么？为什么要有GC？

GC是垃圾收集的意思，内存处理是编程人员容易出问题的地方，忘记或者错误的内存回收会导致程序或者系统的不稳定甚至崩溃，JAVA提供的GC功能可以自动检测对象是否超过作用域从而达到自动回收内存的目的，JAVA语言没有提供释放已分配内存的显示操作方法，Java程序员不用担心内存管理，垃圾收集器会自动进行管理

## 2、说下JVM的主要组成部分，及其作用
![JVM架构图](/img/jvm-s.png)
- ClassLoader 类加载器：将文件加载到内存中。ClassLoader只负责加载，只要符合文件结构就加载，至于能否运行，它不负责。
- exection engine: 执行引擎，也叫解释器，负责解释命令，交由操作系统执行。  
  native interface：本地接口。本地接口的作用是融合不同的语言为java所用。
- Runtimedata area 运行数据区：运行数据区是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。
- stack：栈也叫栈内存，是java程序的运行区，是在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束栈内存释放；对于栈来说不存在垃圾回收的问题，只要线程一结束，该栈就结束。栈中的数据以栈帧的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的集合，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。
- 堆内存：一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类的加载器读取了类文件之后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分三部分：永久存储（用于存放jdk自身携带的class,interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载至此区域的数据是不会被垃圾回收掉的，只有关闭jvm释放此区域所占用的内存）区、新生区、老年代
- method area方法区：方法去是被所有线程共享，该区域保存的所有字段和字节方法码以及一些特殊方法如构造函数，接口代码也在此定义。
- PC Register 程序计数器：每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令`

## 3、说一下JVM运行时数据区
![运行时数据区](/img/runtimeDataArea.png)
不同虚拟机的运行时数据区可能略有不同，但都会遵从Java虚拟机规范，Java虚拟机规范规定的区域分为5个部分：
- 程序计数器（PC）： 当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；
- 虚拟机栈：用于存储局部变量表、操作数栈、动态链栈、方法出口等信息；
- 本地方法栈：与虚拟机栈作用一样，只不过虚拟机栈是服务Java方法的，而本地方法栈是未虚拟机调用Native方法服务的；
- Java堆：Java虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；
- 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

## 4、说一下堆栈的区别
功能方面：堆是用来存放对象的，栈是用来执行程序的  
共享性：堆是线程共享的，栈是线程私有的  
空间大小：堆的大小远远大于栈

## 5、什么是双亲委派模型

> 类加载器的分类：  
> BootStrap ClassLoader : 是虚拟机自身的一部分，用来加载JAVA_HOME/lib/目录中的，或者被-Xbootclasspath参数所指定的路径中并且被虚拟机识别的类库；  
> Extension ClassLoader : 负责加载/lib/ext目录或java.ext.dirs系统变量指定的路径中的所有类库；  
> Application ClassLoader : 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器，默认使用这个加载器  
> Custom ClassLoader : 自定义加载器


![类加载器](/img/classLoader.png)
双亲委派模型：如果一个类加载器收到了类加载请求，它首先不会自己区加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父类无法完成加载请求（它的搜索范围中没有找到所需要的类）时，子加载器才会尝试去加载类。